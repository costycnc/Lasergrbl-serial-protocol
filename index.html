<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fake GRBL Minimal – Explained for Beginners</title>
<style>
    body { font-family: Arial, sans-serif; line-height: 1.6; background: #f9f9f9; padding: 20px; }
    h1, h2, h3 { color: #333; }
    code { background: #eee; padding: 2px 5px; border-radius: 3px; }
    pre { background: #eee; padding: 10px; border-radius: 5px; overflow-x: auto; }
    .important { color: #c00; font-weight: bold; }
    ul { margin-left: 20px; }
</style>
</head>
<body>

<h1>Fake GRBL Minimal – Line by Line Explanation</h1>

<p>This page explains the AVR ASM code for a minimal "Fake GRBL". We will go line by line, in simple language, for students and beginners.</p>

    <p> This code Fake GRBL Minimal - asm from ino.asm is functional and can upload to arduino with <a href="https://www.costycnc.it/avr1">https://www.costycnc.it/avr1</a>  </p>

<h2>1. Program Start</h2>
<pre>
.org 0x0000
rjmp RESET
</pre>
<p><strong>Explanation:</strong> This tells the microcontroller to start the program at the label <code>RESET</code>. It's like telling Arduino "begin at setup()".</p>

<h2>2. Setup USART (Serial)</h2>
<pre>
.org 0x60
RESET:
    ldi r16, 0b00000000
    sts 0xC5, r16
    ldi r16, 0b00001000
    sts 0xC4, r16
    ldi r16, 0b00011000
    sts 0xC1, r16
    ldi r16, 0b00000110
    sts 0xC2, r16
</pre>
<p><strong>Explanation:</strong> This initializes the serial port:</p>
<ul>
<li><code>0xC5</code> and <code>0xC4</code> set the baud rate (speed 115200).</li>
<li><code>0xC1</code> enables RX (receive) and TX (transmit).</li>
<li><code>0xC2</code> sets 8 data bits, no parity, 1 stop bit.</li>
<li>Equivalent Arduino: <code>Serial.begin(115200);</code></li>
</ul>

<h2>3. Main Loop</h2>
<pre>
MAIN_LOOP:
WAIT_RX:
    lds r16, 0xC0
    sbrc r16, 7
    rjmp GOT_RX
    rjmp WAIT_RX

GOT_RX:
    lds r16, 0xC6
</pre>
<p><strong>Explanation:</strong> This waits for a byte from the host:</p>
<ul>
<li>Check if a byte is available (<code>RXC0</code> bit in <code>UCSR0A</code>).</li>
<li>If no byte, it loops until one arrives.</li>
<li>Once a byte arrives, we read it from <code>UDR0</code> into <code>r16</code>.</li>
<li>Equivalent Arduino: <code>while(!Serial.available()); r16 = Serial.read();</code></li>
</ul>

<h2>4. Check the Byte</h2>
<pre>
cpi r16, 0x0A
breq SEND_OK
cpi r16, '?'
breq SEND_STATUS
rjmp SEND_OK
</pre>
<p><strong>Explanation:</strong> This checks what the byte is:</p>
<ul>
<li>If it's <code>0x0A</code> (newline, '\n'), send "ok".</li>
<li>If it's <code>?</code>, send the status string.</li>
<li>If it's anything else, send "ok" anyway (for compatibility).</li>
</ul>

<h2>5. Sending a String</h2>
<pre>
SEND_OK:
    ldi r30, low(MSG_OK*2)
    ldi r31, high(MSG_OK*2)

SEND_OK_LOOP:
    lpm r16, Z+
    cpi r16, 0
    breq MAIN_LOOP
WAIT_TX_OK:
    lds r17, 0xC0
    sbrs r17, 5
    rjmp WAIT_TX_OK
    sts 0xC6, r16
    rjmp SEND_OK_LOOP
</pre>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>MSG_OK</code> points to "ok\n" in flash memory.</li>
<li>The loop reads one byte at a time (<code>lpm</code>) until it reaches <code>0</code> (string terminator).</li>
<li>Before writing to <code>UDR0</code>, it waits until the transmit buffer is ready (<code>UDRE0</code> bit).</li>
<li>Equivalent Arduino: <code>Serial.println("ok");</code></li>
</ul>

<h2>6. Status String</h2>
<pre>
SEND_STATUS:
    ldi r30, low(MSG_STATUS*2)
    ldi r31, high(MSG_STATUS*2)
    rcall SEND_STRING
</pre>
<p><strong>Explanation:</strong> Same as "ok", but sends the status string to the host.</p>

<h2>7. Strings in Flash</h2>
<pre>
MSG_OK:
    .db "ok",10,0

MSG_STATUS:
    .db "&lt;Idle|MPos:0.000,0.000,0.000|FS:0,0|WCO:0.000,0.000,0.000&gt;",10,0
</pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>Every string ends with <code>0</code> → tells AVR where the string ends.</li>
<li><code>10</code> → ASCII <code>\n</code>, tells host that line ended.</li>
<li>This is why the host responds "ok" correctly when you press arrow keys in LaserGRBL.</li>
</ul>

<h2>8. Why This Matters</h2>
<p class="important">Most beginners forget <code>\n</code> or <code>0</code> terminators. The microcontroller then keeps sending garbage, or the host never replies. Studying this ASM code teaches you how serial communication works byte-by-byte, including waiting for buffer, reading flash, and sending bytes.</p>

<h2>9. Summary</h2>
<ul>
<li>Every string must end with <code>0</code> (terminator).</li>
<li>Every host command often expects <code>\n</code> to process the line.</li>
<li>Low-level AVR teaches you what Arduino hides.</li>
<li>By following this step-by-step code, you understand exactly what happens under <code>Serial.println()</code>.</li>
</ul>

</body>
</html>

